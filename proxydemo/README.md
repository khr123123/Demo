Java 动态代理三种实现方式总结（JDK、CGLIB、Javassist）
在 Java 中，动态代理是一种在运行时创建代理对象、拦截方法调用并添加增强逻辑的技术。MyBatis、Spring AOP 等框架都大量使用了动态代理机制。常见实现方式有三种：

一、JDK 动态代理
📌 核心特点
Java 原生支持，无需第三方库。

只能代理 接口，不能代理普通类。

基于 java.lang.reflect.Proxy 和反射机制。

实现简单，性能相对较低。

✅ 适用场景
服务或组件以接口方式对外暴露。

对性能要求不高的场合。

如：MyBatis 的 Mapper 接口代理、Spring AOP 默认使用（JDK 优先）。

二、CGLIB 动态代理
📌 核心特点
可以代理 类，也可以代理实现了接口的类。

基于继承与字节码增强（使用 ASM 库）。

被代理类不能是 final 类，代理方法也不能是 final 方法。

Spring 在没有接口时默认使用 CGLIB。

✅ 适用场景
无法修改目标类定义为接口时。

需要对类方法进行增强时。

比 JDK Proxy 性能更优（但创建代理类耗时略高）。

三、Javassist 动态代理
📌 核心特点
基于字节码编辑（底层使用 ASM）。

可以动态生成类，也可代理接口或类。

灵活性强，可直接拼接方法体字符串或操作字节码结构。

性能优于 JDK Proxy，略低于 CGLIB，但功能更底层可控。

✅ 适用场景
高性能、高灵活性的场合。

框架级开发，需要控制字节码结构。

如：MyBatis 的代理类在低版本中可使用 Javassist 实现。

🔍 三者对比表
| 特性        | JDK Proxy          | CGLIB        | Javassist          |
| --------- | ------------------ | ------------ | ------------------ |
| 是否依赖三方库   | 否                  | 是（需引入 CGLIB） | 是（需引入 Javassist）   |
| 能否代理类     | 否（仅限接口）            | 是            | 是                  |
| 实现方式      | 反射                 | 继承 + 字节码增强   | 直接编辑字节码            |
| 被代理类限制    | 无                  | 类不能为 final   | 类不能为 final         |
| 性能（方法调用时） | 慢                  | 快            | 中等                 |
| 灵活性       | 低                  | 中            | 高                  |
| 常见使用场景    | 普通接口服务             | Spring 无接口代理 | 自定义代理、框架底层         |
| 常见框架应用    | MyBatis、Spring AOP | Spring AOP   | MyBatis、Hibernate等 |


✅ 总结推荐
| 使用需求           | 推荐方式                          |
| -------------- | ----------------------------- |
| 项目中都是接口，追求简单   | JDK Proxy                     |
| 无法使用接口，需要代理普通类 | CGLIB                         |
| 框架开发，需要字节码编辑能力 | Javassist                     |
| 关注性能，方法调用频繁    | CGLIB > Javassist > JDK Proxy |

